// src/utils/sqlGenerator.ts
import { parse } from '@joe-re/sql-parser';
import {
  DiagramState,
  Column,
  TableData,
  Constraint,
  RelationshipSuggestion,
  TableNode,
  RelationshipEdge,
  ColumnType,
} from "../types";

// --- SQL GENERATION ---

export function generateSQL(
  state: DiagramState,
  dialect: string = "mysql"
): string {
  const { nodes } = state; // Edges are implicit in TableData column foreign key definitions

  let sql = "";
  sql += `-- SQL Generated by ERD Tool\n`;
  sql += `-- Dialect: ${dialect}\n`;
  sql += `-- Generated on: ${new Date().toLocaleString()}\n\n`;

  // For PostgreSQL, generate custom ENUM types first
  if (dialect === "postgresql") {
    const enumTypes = new Map<string, string[]>();
    nodes.forEach((node) => {
      node.data.columns.forEach((column) => {
        if (
          column.type === "ENUM" &&
          column.enumValues &&
          column.enumValues.length > 0
        ) {
          const typeName = `${node.data.tableName}_${column.name}_enum`;
          if (!enumTypes.has(typeName)) {
            enumTypes.set(typeName, column.enumValues);
          }
        }
      });
    });

    if (enumTypes.size > 0) {
      sql += `-- ENUM TYPE DEFINITIONS --\n`;
      enumTypes.forEach((values, typeName) => {
        sql += `CREATE TYPE ${formatIdentifier(typeName, dialect)} AS ENUM (\n`;
        sql += values.map((v) => `  '${v.replace(/'/g, "''")}'`).join(",\n");
        sql += `\n);\n\n`;
      });
    }
  }

  nodes.forEach((node) => {
    const tableData: TableData = node.data;
    let tableName = formatIdentifier(tableData.tableName, dialect);
    if (
      tableData.schema &&
      tableData.schema.toLowerCase() !== "public" &&
      (dialect === "postgresql" || dialect === "sqlserver")
    ) {
      tableName = `${formatIdentifier(tableData.schema, dialect)}.${tableName}`;
    }

    if (tableData.comment && (dialect === "mysql" || dialect === "sqlserver")) {
      // PostgreSQL comments are added later
      sql += `-- Table: ${tableName}\n`;
      sql += `-- Comment: ${tableData.comment}\n`;
    }
    sql += `CREATE TABLE ${tableName} (\n`;

    const columnDefinitions: string[] = [];
    const tableConstraints: string[] = [];

    tableData.columns.forEach((column, colIndex) => {
      let columnSql = `  ${formatIdentifier(
        column.name,
        dialect
      )} ${formatColumnType(column, dialect, tableData.tableName)}`;

      if (column.isAutoIncrement) {
        if (dialect === "mysql") columnSql += " AUTO_INCREMENT";
        // SERIAL/IDENTITY for pg/sqlserver handled in formatColumnType
      }

      if (!column.isNullable) {
        columnSql += " NOT NULL";
      }

      const defaultConstraint = column.constraints?.find(
        (c) => c.type === "DEFAULT"
      );
      if (defaultConstraint?.defaultValue !== undefined) {
        columnSql += ` DEFAULT ${formatDefaultValue(
          defaultConstraint.defaultValue,
          column.type,
          dialect
        )}`;
      }

      if (column.isUnique) {
        // For single column unique, can be inline or table constraint. Let's prefer inline for simplicity.
        columnSql += " UNIQUE";
      }

      if (column.comment && dialect === "mysql") {
        columnSql += ` COMMENT '${column.comment.replace(/'/g, "''")}'`;
      }
      // SQL Server inline column comments are not standard SQL; usually done with sp_addextendedproperty

      columnDefinitions.push(columnSql);

      // Foreign Key constraints (can be inline or table level, prefer table level for clarity)
      if (
        column.isForeignKey &&
        column.referencesTable &&
        column.referencesColumn
      ) {
        let fkConstraint = `CONSTRAINT ${formatIdentifier(
          `FK_${tableData.tableName}_${column.name}`,
          dialect
        )} `;
        fkConstraint += `FOREIGN KEY (${formatIdentifier(
          column.name,
          dialect
        )}) `;

        let refTable = formatIdentifier(column.referencesTable, dialect);
        if (
          column.referencesSchema &&
          column.referencesSchema.toLowerCase() !== "public" &&
          (dialect === "postgresql" || dialect === "sqlserver")
        ) {
          refTable = `${formatIdentifier(
            column.referencesSchema,
            dialect
          )}.${refTable}`;
        }
        fkConstraint += `REFERENCES ${refTable}(${formatIdentifier(
          column.referencesColumn,
          dialect
        )})`;

        if (column.onUpdate)
          fkConstraint += ` ON UPDATE ${column.onUpdate.toUpperCase()}`;
        if (column.onDelete)
          fkConstraint += ` ON DELETE ${column.onDelete.toUpperCase()}`;
        tableConstraints.push(fkConstraint);
      }

      // CHECK constraints for column
      column.constraints
        ?.filter((c) => c.type === "CHECK" && c.expression)
        .forEach((constraint, cIndex) => {
          tableConstraints.push(
            `CONSTRAINT ${formatIdentifier(
              `CHK_${tableData.tableName}_${column.name}_${cIndex}`,
              dialect
            )} CHECK (${constraint.expression})`
          );
        });
    });

    const primaryKeys = tableData.columns.filter((col) => col.isPrimaryKey);
    if (primaryKeys.length > 0) {
      tableConstraints.unshift(
        // Add PK constraint first
        `CONSTRAINT ${formatIdentifier(
          `PK_${tableData.tableName}`,
          dialect
        )} PRIMARY KEY (${primaryKeys
          .map((pk) => formatIdentifier(pk.name, dialect))
          .join(", ")})`
      );
    }

    sql += columnDefinitions.join(",\n");
    if (tableConstraints.length > 0) {
      sql += ",\n" + tableConstraints.map((c) => `  ${c}`).join(",\n");
    }
    sql += "\n)";

    if (dialect === "mysql") {
      sql +=
        " ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci";
    }
    sql += ";\n";

    if (dialect === "postgresql") {
      if (tableData.comment) {
        sql += `COMMENT ON TABLE ${tableName} IS '${tableData.comment.replace(
          /'/g,
          "''"
        )}';\n`;
      }
      tableData.columns.forEach((column) => {
        if (column.comment) {
          sql += `COMMENT ON COLUMN ${tableName}.${formatIdentifier(
            column.name,
            dialect
          )} IS '${column.comment.replace(/'/g, "''")}';\n`;
        }
      });
    }
    // For SQL Server, comments are typically added using sp_addextendedproperty, which is more complex.
    sql += "\n";
  });

  // Add indexes (simple example, could be more complex)
  nodes.forEach((node) => {
    const tableData = node.data;
    tableData.columns.forEach((column) => {
      if (column.shouldCreateIndex) {
        // Add a new property to Column type if needed
        let fullTableName = formatIdentifier(tableData.tableName, dialect);
        if (
          tableData.schema &&
          tableData.schema.toLowerCase() !== "public" &&
          (dialect === "postgresql" || dialect === "sqlserver")
        ) {
          fullTableName = `${formatIdentifier(
            tableData.schema,
            dialect
          )}.${fullTableName}`;
        }
        sql += `CREATE INDEX ${formatIdentifier(
          `IDX_${tableData.tableName}_${column.name}`,
          dialect
        )} ON ${fullTableName} (${formatIdentifier(column.name, dialect)});\n`;
      }
    });
    if (tableData.columns.some((c) => c.shouldCreateIndex)) sql += "\n";
  });

  return sql;
}

function formatIdentifier(name: string, dialect: string): string {
  if (!name) return '""'; // Should not happen with valid data
  // Avoid double-quoting if already quoted (simple check)
  if (
    (dialect === "postgresql" && name.startsWith('"') && name.endsWith('"')) ||
    (dialect === "mysql" && name.startsWith("`") && name.endsWith("`")) ||
    (dialect === "sqlserver" && name.startsWith("[") && name.endsWith("]"))
  ) {
    return name;
  }
  switch (dialect) {
    case "mysql":
      return `\`${name.replace(/`/g, "``")}\``; // Escape backticks
    case "postgresql":
      return `"${name.replace(/"/g, '""')}"`; // Escape double quotes
    case "sqlserver":
      return `[${name.replace(/]/g, "]]")}]`; // Escape closing bracket
    default: // fallback to ANSI quotes
      return `"${name.replace(/"/g, '""')}"`;
  }
}

function formatDefaultValue(
  value: string | number | boolean,
  type: ColumnType,
  dialect: string
): string {
  if (typeof value === "string") {
    // Handle common function calls (case-insensitive)
    const upperValue = value.toUpperCase();
    if (upperValue === "CURRENT_TIMESTAMP" || upperValue === "NOW()") {
      if (dialect === "sqlserver") return "GETDATE()";
      return "CURRENT_TIMESTAMP"; // MySQL and PostgreSQL
    }
    if (upperValue === "NEWID()" && dialect === "sqlserver") return "NEWID()";
    if (upperValue === "GEN_RANDOM_UUID()" && dialect === "postgresql")
      return "GEN_RANDOM_UUID()";
    if (upperValue === "UUID()" && dialect === "mysql") return "UUID()";

    if (type === "BOOLEAN") {
      if (value.toLowerCase() === "true")
        return dialect === "postgresql" ? "TRUE" : "1";
      if (value.toLowerCase() === "false")
        return dialect === "postgresql" ? "FALSE" : "0";
    }

    // For string types, or if it looks like a function call not handled above, or non-numeric string for numeric type (error case by user)
    if (
      type === "VARCHAR" ||
      type === "TEXT" ||
      type === "CHAR" ||
      type === "JSON" ||
      type === "UUID" ||
      type === "ENUM" ||
      value.includes("(")
    ) {
      return `'${value.replace(/'/g, "''")}'`;
    }
    return value; // Assume it's a number meant for a numeric type, or a pre-formatted value
  }
  if (typeof value === "number") return value.toString();
  if (typeof value === "boolean") {
    if (dialect === "postgresql") return value ? "TRUE" : "FALSE";
    return value ? "1" : "0";
  }
  return "NULL"; // Fallback
}

function formatColumnType(
  column: Column,
  dialect: string,
  tableName?: string
): string {
  // Common type mappings
  const baseType = column.type.toUpperCase();
  switch (baseType) {
    case "INT":
    case "INTEGER":
      if (column.isAutoIncrement) {
        if (dialect === "postgresql") return "SERIAL";
        if (dialect === "sqlserver") return "INT IDENTITY(1,1)";
        // MySQL AUTO_INCREMENT is added separately
      }
      return dialect === "postgresql" ? "INTEGER" : "INT";
    case "BIGINT":
      if (column.isAutoIncrement) {
        if (dialect === "postgresql") return "BIGSERIAL";
        if (dialect === "sqlserver") return "BIGINT IDENTITY(1,1)";
      }
      return "BIGINT";
    case "VARCHAR":
      return `VARCHAR(${column.length || 255})`;
    case "CHAR":
      return `CHAR(${column.length || 1})`;
    case "TEXT":
      if (dialect === "sqlserver") return "NVARCHAR(MAX)";
      return "TEXT";
    case "BOOLEAN":
      if (dialect === "mysql") return "TINYINT(1)";
      if (dialect === "sqlserver") return "BIT";
      return "BOOLEAN";
    case "DATE":
      return "DATE";
    case "TIMESTAMP":
    case "DATETIME":
      // For PostgreSQL, TIMESTAMP WITH TIME ZONE is often preferred: column.options?.useTimezone ? "TIMESTAMP WITH TIME ZONE" : "TIMESTAMP WITHOUT TIME ZONE"
      return dialect === "sqlserver" ? "DATETIME2" : "TIMESTAMP";
    case "TIME":
      return "TIME";
    case "FLOAT":
      return dialect === "postgresql" ? "REAL" : "FLOAT"; // REAL is single precision in PG
    case "DOUBLE":
    case "DOUBLE PRECISION":
      return dialect === "postgresql" ? "DOUBLE PRECISION" : "DOUBLE";
    case "DECIMAL":
    case "NUMERIC":
      return `DECIMAL(${column.precision || 10}, ${column.scale || 2})`;
    case "JSON":
      if (dialect === "mysql" || dialect === "postgresql") return "JSON";
      if (dialect === "sqlserver") return "NVARCHAR(MAX)"; // SQL Server 2016+ has JSON support
      return "TEXT"; // Fallback
    case "JSONB":
      if (dialect === "postgresql") return "JSONB";
      return "JSON"; // Fallback to JSON
    case "UUID":
      if (dialect === "postgresql") return "UUID";
      if (dialect === "mysql") return "CHAR(36)";
      if (dialect === "sqlserver") return "UNIQUEIDENTIFIER";
      return "VARCHAR(36)";
    case "ENUM":
      if (dialect === "postgresql" && tableName && column.name) {
        return formatIdentifier(`${tableName}_${column.name}_enum`, dialect); // Use the created custom type
      }
      if (dialect === "mysql" && column.enumValues) {
        return `ENUM(${column.enumValues
          .map((v) => `'${v.replace(/'/g, "''")}'`)
          .join(", ")})`;
      }
      return `VARCHAR(${column.length || 50})`; // Fallback for other dialects or missing enumValues
    case "BLOB":
    case "BYTEA":
      if (dialect === "postgresql") return "BYTEA";
      if (dialect === "sqlserver") return "VARBINARY(MAX)";
      return "BLOB"; // MySQL
    // Add more types as needed: ARRAY, XML, etc.
    default:
      // If it's a user-defined type (e.g., from another part of a script)
      if (column.type.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/))
        return formatIdentifier(column.type, dialect);
      return `VARCHAR(${column.length || 255})`; // Fallback for unknown
  }
}

// --- SQL PARSING ---

// Helper to remove comments and normalize whitespace
function preprocessSql(sql: string): string {
  // Remove block comments /* ... */
  sql = sql.replace(/\/\*[\s\S]*?\*\/|--.*$/gm, "");
  // Normalize whitespace: multiple spaces/newlines to single space
  sql = sql.replace(/\s+/g, " ").trim();
  return sql;
}

// A simplified regex for identifier (table/column name)
const IDENTIFIER_REGEX_PART = '[`"\\[]?([a-zA-Z_][a-zA-Z0-9_$\\.]*)[`"\\]]?'; // Allows schema.table
const QUALIFIED_IDENTIFIER_REGEX = new RegExp(
  `(?:${IDENTIFIER_REGEX_PART}\\.)?${IDENTIFIER_REGEX_PART}`,
  "i"
);


export function parseSQL(
  sqlInput: string,
  dialect: string = 'mysql'
): DiagramState {
  const tablesData: TableData[] = [];
  const edges: RelationshipEdge[] = [];
  let tableCounter = 0;

  let ast;
  try {
    ast = parse(sqlInput);
  } catch (error) {
    console.error('SQL parsing error:', error);
    return { nodes: [], edges: [] };
  }

  for (const statement of ast) {
    if (statement.type === 'create_table') {
      const tableId = `table-${Date.now()}-${tableCounter++}`;
      const schemaName =
        statement.schema || (dialect === 'postgresql' ? 'public' : undefined);
      const tableName = statement.name;
      const currentTable: TableData = {
        id: tableId,
        tableName,
        schema: schemaName,
        columns: [],
        comment: undefined,
      };

      for (const columnDef of statement.columns) {
        const column: Column = {
          id: `${tableId}-col-${currentTable.columns.length}`,
          name: columnDef.name,
          type: columnDef.datatype.toUpperCase(),
          isNullable: !columnDef.not_null,
          isPrimaryKey: columnDef.primary_key || false,
          isForeignKey: false,
          isUnique: columnDef.unique || false,
          isAutoIncrement: columnDef.auto_increment || false,
          constraints: [],
          comment: columnDef.comment,
          referencesTable: undefined,
          referencesColumn: undefined,
          referencesSchema: undefined,
          onDelete: undefined,
          onUpdate: undefined,
        };

        if (columnDef.default !== undefined) {
          column.constraints!.push({
            type: 'DEFAULT',
            defaultValue: columnDef.default,
          });
        }

        currentTable.columns.push(column);
      }

      for (const constraint of statement.constraints || []) {
        if (constraint.type === 'foreign_key') {
          const fkColumnName = constraint.columns[0];
          const refTable = constraint.references.table;
          const refColumn = constraint.references.columns[0];
          const refSchema =
            constraint.references.schema ||
            (dialect === 'postgresql' ? 'public' : undefined);
          const onDelete = constraint.on_delete;
          const onUpdate = constraint.on_update;

          const col = currentTable.columns.find(
            (c) => c.name === fkColumnName
          );
          if (col) {
            col.isForeignKey = true;
            col.referencesTable = refTable;
            col.referencesColumn = refColumn;
            col.referencesSchema = refSchema;
            col.onDelete = onDelete;
            col.onUpdate = onUpdate;
          }
        } else if (constraint.type === 'primary_key') {
          for (const pkColName of constraint.columns) {
            const col = currentTable.columns.find(
              (c) => c.name === pkColName
            );
            if (col) {
              col.isPrimaryKey = true;
              col.isNullable = false;
            }
          }
        } else if (constraint.type === 'unique') {
          for (const uqColName of constraint.columns) {
            const col = currentTable.columns.find(
              (c) => c.name === uqColName
            );
            if (col) {
              col.isUnique = true;
            }
          }
        } else if (constraint.type === 'check') {
          if (currentTable.columns.length > 0) {
            if (!currentTable.columns[0].constraints)
              currentTable.columns[0].constraints = [];
            currentTable.columns[0].constraints!.push({
              type: 'CHECK',
              expression: constraint.expression,
            });
          }
        }
      }

      tablesData.push(currentTable);
    } else if (statement.type === 'comment') {
      if (statement.object === 'table') {
        const schemaName =
          statement.schema || (dialect === 'postgresql' ? 'public' : undefined);
        const tableName = statement.name;
        const comment = statement.comment;
        const table = tablesData.find(
          (t) =>
            t.tableName === tableName &&
            (schemaName ? t.schema === schemaName : true)
        );
        if (table) table.comment = comment;
      } else if (statement.object === 'column') {
        const schemaName =
          statement.schema || (dialect === 'postgresql' ? 'public' : undefined);
        const tableName = statement.table;
        const columnName = statement.name;
        const comment = statement.comment;
        const table = tablesData.find(
          (t) =>
            t.tableName === tableName &&
            (schemaName ? t.schema === schemaName : true)
        );
        if (table) {
          const column = table.columns.find((c) => c.name === columnName);
          if (column) column.comment = comment;
        }
      }
    }
  }

  const finalNodes: TableNode[] = tablesData.map((td, index) => ({
    id: td.id,
    type: 'tableNode',
    position: {
      x: (index % 4) * 300 + 50,
      y: Math.floor(index / 4) * 250 + 50,
    },
    data: td,
  }));

  finalNodes.forEach((sourceNode) => {
    sourceNode.data.columns.forEach((column) => {
      if (
        column.isForeignKey &&
        column.referencesTable &&
        column.referencesColumn
      ) {
        const targetNode = finalNodes.find(
          (n) =>
            n.data.tableName === column.referencesTable &&
            (column.referencesSchema
              ? n.data.schema === column.referencesSchema
              : true)
        );
        if (targetNode) {
          edges.push({
            id: `edge-${sourceNode.id}-${targetNode.id}-${column.name}`,
            source: targetNode.id,
            target: sourceNode.id,
            data: {
              relationshipType: 'one-to-many',
              sourceTable: targetNode.data.tableName,
              sourceColumn: column.referencesColumn,
              targetTable: sourceNode.data.tableName,
              targetColumn: column.name,
              onUpdate: column.onUpdate,
              onDelete: column.onDelete,
            },
          });
        }
      }
    });
  });

  return { nodes: finalNodes, edges };
}

// --- SQL FORMATTING FOR DISPLAY (existing function, largely unchanged but can be improved) ---
export function formatSQLForDisplay(sql: string): string {
  // This is a basic formatter. For robust highlighting, consider a library like 'highlight.js' or 'prismjs'
  // adapted for SQL, or a more advanced regex approach.
  let formattedSql = sql
    // Escape HTML special characters to prevent XSS if displaying raw input
    .replace(/&/g, "&")
    .replace(/</g, "<")
    .replace(/>/g, ">");

  // Keywords
  formattedSql = formattedSql.replace(
    /\b(CREATE|TABLE|PRIMARY|KEY|FOREIGN|REFERENCES|INT(?:EGER)?|VARCHAR|TEXT|BOOLEAN|DATE|TIMESTAMP|DATETIME|FLOAT|DOUBLE|DECIMAL|NUMERIC|CHAR|ENUM|BLOB|BYTEA|SERIAL|BIGSERIAL|IDENTITY|NOT|NULL|UNIQUE|CHECK|DEFAULT|CONSTRAINT|INDEX|ON|COMMENT|IS|ENGINE|CHARSET|COLLATE|ALTER|ADD|DROP|INSERT|INTO|VALUES|UPDATE|SET|DELETE|FROM|WHERE|SELECT|AS|JOIN|INNER|LEFT|RIGHT|OUTER|GROUP|BY|ORDER|ASC|DESC|LIMIT|OFFSET|CASE|WHEN|THEN|ELSE|END|TYPE|CASCADE|RESTRICT|SET\s+NULL|NO\s+ACTION|AUTO_INCREMENT)\b/gi,
    (match) => `<span class="keyword">${match}</span>`
  );
  // Identifiers (quoted)
  formattedSql = formattedSql.replace(
    /([`"\[])([^`"\[\]]+)([`"\]])/g,
    (match, open, identifier, close) =>
      `${open}<span class="identifier">${identifier}</span>${close}`
  );
  // Data types (already partially covered by keywords, but this can refine)
  formattedSql = formattedSql.replace(
    /(<span class="keyword">(?:INT(?:EGER)?|VARCHAR|TEXT|BOOLEAN|DATE|TIMESTAMP|DATETIME|FLOAT|DOUBLE|DECIMAL|NUMERIC|CHAR|ENUM|BLOB|BYTEA|SERIAL|BIGSERIAL|IDENTITY)<\/span>)(\(\s*\d+(?:\s*,\s*\d+)?\s*\))?/gi,
    (match, type, params) =>
      `<span class="data-type">${type}${params || ""}</span>`
  );
  // String literals
  formattedSql = formattedSql.replace(
    /'((?:[^']|'')*)'/g,
    (match) => `<span class="string-literal">${match}</span>`
  );
  // Numeric literals
  formattedSql = formattedSql.replace(
    /\b(\d+(?:\.\d+)?)\b/g,
    (match, number) => `<span class="numeric-literal">${number}</span>`
  );
  // Comments
  formattedSql = formattedSql.replace(
    /(--[^\r\n]*)/g,
    (match) => `<span class="comment">${match}</span>`
  );
  formattedSql = formattedSql.replace(
    /(\/\*[\s\S]*?\*\/)/g,
    (match) => `<span class="comment">${match}</span>`
  );

  return formattedSql.replace(/\n/g, "<br>"); // Preserve line breaks for HTML display
}

// --- RELATIONSHIP SUGGESTION (existing function, largely unchanged) ---
export function suggestRelationships(
  tableNodes: TableNode[]
): RelationshipSuggestion[] {
  const suggestions: RelationshipSuggestion[] = [];
  const nodes = tableNodes.map((tn) => tn.data); // Work with TableData

  // Build edges from existing foreign keys to avoid duplicate suggestions
  const edges: RelationshipEdge[] = [];
  tableNodes.forEach((sourceNode) => {
    sourceNode.data.columns.forEach((column) => {
      if (
        column.isForeignKey &&
        column.referencesTable &&
        column.referencesColumn
      ) {
        const targetNode = tableNodes.find(
          (n) =>
            n.data.tableName === column.referencesTable &&
            (column.referencesSchema
              ? n.data.schema === column.referencesSchema
              : true)
        );
        if (targetNode) {
          edges.push({
            id: `edge-${sourceNode.id}-${targetNode.id}-${column.name}`,
            source: targetNode.id,
            target: sourceNode.id,
            data: {
              relationshipType: "one-to-many",
              sourceTable: targetNode.data.tableName,
              sourceColumn: column.referencesColumn,
              targetTable: sourceNode.data.tableName,
              targetColumn: column.name,
              onUpdate: column.onUpdate,
              onDelete: column.onDelete,
            },
          });
        }
      }
    });
  });

  for (let i = 0; i < nodes.length; i++) {
    const sourceTable = nodes[i];
    for (let j = 0; j < nodes.length; j++) {
      if (i === j) continue;
      const targetTable = nodes[j];

      // Heuristic 1: Foreign key naming convention (e.g., users.id -> posts.user_id)
      const sourcePK = sourceTable.columns.find((col) => col.isPrimaryKey);
      if (sourcePK) {
        targetTable.columns.forEach((targetColumn) => {
          const targetColNameLower = targetColumn.name.toLowerCase();
          const sourceTableNameLower = sourceTable.tableName.toLowerCase();
          const expectedFkNameStyle1 = `${sourceTableNameLower}_${sourcePK.name.toLowerCase()}`; // e.g. user_id
          const expectedFkNameStyle2 = `${sourceTableNameLower}id`; // e.g. userid

          if (
            (targetColNameLower === expectedFkNameStyle1 ||
              targetColNameLower === expectedFkNameStyle2) &&
            targetColumn.type === sourcePK.type && // Basic type check
            !targetColumn.isPrimaryKey
          ) {
            // FKs are usually not PKs in the target table (unless it's a 1-1 relationship table)

            // Avoid suggesting if already an FK
            const existingEdge = edges.find(
              (e) =>
                e.data.sourceTable === sourceTable.tableName &&
                e.data.targetTable === targetTable.tableName &&
                e.data.targetColumn === targetColumn.name
            );
            if (!existingEdge) {
              suggestions.push({
                sourceTable: sourceTable.tableName,
                sourceColumn: sourcePK.name,
                targetTable: targetTable.tableName,
                targetColumn: targetColumn.name,
                relationshipType: "one-to-many",
                confidence: 0.8,
                reason: `Column "${targetColumn.name}" in "${targetTable.tableName}" matches naming convention for foreign key to "${sourceTable.tableName}.${sourcePK.name}".`,
              });
            }
          }
        });
      }

      // Heuristic 2: Junction table for many-to-many
      // A table with 2 (or more) FKs, and possibly only those + a PK.
      if (targetTable.columns.filter((col) => col.isForeignKey).length >= 2) {
        const fks = targetTable.columns.filter((col) => col.isForeignKey);
        // Check if one FK points to sourceTable, and another to a *different* table
        const fkToSource = fks.find(
          (fk) => fk.referencesTable === sourceTable.tableName
        );
        if (fkToSource) {
          fks.forEach((otherFk) => {
            if (
              otherFk.referencesTable &&
              otherFk.referencesTable !== sourceTable.tableName
            ) {
              const thirdTable = nodes.find(
                (n) => n.tableName === otherFk.referencesTable
              );
              if (thirdTable) {
                suggestions.push({
                  sourceTable: sourceTable.tableName, // Table A
                  targetTable: thirdTable.tableName, // Table C
                  // Junction table is targetTable (Table B)
                  relationshipType: "many-to-many",
                  confidence: 0.7,
                  reason: `Table "${targetTable.tableName}" appears to be a junction table between "${sourceTable.tableName}" and "${thirdTable.tableName}".`,
                });
              }
            }
          });
        }
      }
    }
  }
  // Deduplicate suggestions (simple deduplication based on source/target tables and type)
  const uniqueSuggestions = suggestions.filter(
    (s, index, self) =>
      index ===
      self.findIndex(
        (t) =>
          t.sourceTable === s.sourceTable &&
          t.targetTable === s.targetTable &&
          t.relationshipType === s.relationshipType &&
          // For one-to-many, also consider columns to differentiate
          (s.relationshipType !== "one-to-many" ||
            (t.sourceColumn === s.sourceColumn &&
              t.targetColumn === s.targetColumn))
      )
  );
  return uniqueSuggestions;
}
