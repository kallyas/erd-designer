
import { DiagramState, Column, TableData, Constraint, RelationshipSuggestion } from "../types";

export function generateSQL(state: DiagramState, dialect: string = "mysql"): string {
  const { nodes, edges } = state;
  
  // Start with creating tables
  let sql = "";
  
  // Add header comment
  sql += `-- SQL Generated by ERD Designer\n`;
  sql += `-- Dialect: ${dialect || "mysql"}\n`;
  sql += `-- Generated on: ${new Date().toLocaleString()}\n\n`;
  
  // Add SQL for each table
  nodes.forEach((node) => {
    const tableData: TableData = node.data;
    
    // Add table comment if exists
    if (tableData.comment) {
      sql += `-- ${tableData.comment}\n`;
    }
    
    // Different syntax for schemas based on dialect
    let tableName = formatTableName(tableData.tableName, dialect);
    if (tableData.schema && tableData.schema !== "public" && (dialect === "postgresql" || dialect === "sqlserver")) {
      tableName = `${formatSchemaName(tableData.schema, dialect)}.${formatTableName(tableData.tableName, dialect)}`;
    }
    
    sql += `CREATE TABLE ${tableName} (\n`;
    
    // Add columns
    const columnDefinitions = tableData.columns.map((column) => {
      let columnSql = `  ${formatColumnName(column.name, dialect)} ${formatColumnType(column, dialect)}`;
      
      // Add NOT NULL constraint if applicable
      if (!column.isNullable) {
        columnSql += " NOT NULL";
      }
      
      // Add DEFAULT constraint if applicable
      const defaultConstraint = column.constraints?.find(c => c.type === 'DEFAULT');
      if (defaultConstraint && defaultConstraint.defaultValue) {
        columnSql += ` DEFAULT ${formatDefaultValue(defaultConstraint.defaultValue, column.type, dialect)}`;
      }
      
      // Check for UNIQUE constraint at column level
      if (column.isUnique) {
        columnSql += " UNIQUE";
      }
      
      // Add column comment for PostgreSQL
      if (column.comment && dialect === "postgresql") {
        // PostgreSQL comments are added after table creation
      } else if (column.comment && dialect === "mysql") {
        columnSql += ` COMMENT '${column.comment.replace(/'/g, "''")}'`;
      }
      
      return columnSql;
    });
    
    // Add primary key constraints
    const primaryKeys = tableData.columns.filter(col => col.isPrimaryKey);
    if (primaryKeys.length > 0) {
      const pkConstraintName = dialect === "postgresql" || dialect === "sqlserver" 
        ? `PK_${tableData.tableName}` 
        : "";
        
      const pkConstraint = dialect === "postgresql" || dialect === "sqlserver"
        ? `  CONSTRAINT ${pkConstraintName} PRIMARY KEY (${primaryKeys.map(pk => formatColumnName(pk.name, dialect)).join(", ")})`
        : `  PRIMARY KEY (${primaryKeys.map(pk => formatColumnName(pk.name, dialect)).join(", ")})`;
        
      columnDefinitions.push(pkConstraint);
    }

    // Add foreign key constraints for columns that are foreign keys
    tableData.columns
      .filter(col => col.isForeignKey && col.referencesTable && col.referencesColumn)
      .forEach((fk, index) => {
        const fkConstraintName = dialect === "postgresql" || dialect === "sqlserver" 
          ? `FK_${tableData.tableName}_${index + 1}` 
          : "";
          
        const fkConstraint = dialect === "postgresql" || dialect === "sqlserver"
          ? `  CONSTRAINT ${fkConstraintName} FOREIGN KEY (${formatColumnName(fk.name, dialect)}) REFERENCES ${formatTableName(fk.referencesTable!, dialect)}(${formatColumnName(fk.referencesColumn!, dialect)})`
          : `  FOREIGN KEY (${formatColumnName(fk.name, dialect)}) REFERENCES ${formatTableName(fk.referencesTable!, dialect)}(${formatColumnName(fk.referencesColumn!, dialect)})`;
          
        columnDefinitions.push(fkConstraint);
      });
    
    // Add CHECK constraints
    tableData.columns.forEach((column, index) => {
      const checkConstraints = column.constraints?.filter(c => c.type === 'CHECK' && c.expression);
      if (checkConstraints && checkConstraints.length > 0) {
        checkConstraints.forEach((constraint, constraintIndex) => {
          const checkName = dialect === "postgresql" || dialect === "sqlserver" 
            ? `CHK_${tableData.tableName}_${index + 1}_${constraintIndex + 1}` 
            : "";
            
          const checkConstraint = dialect === "postgresql" || dialect === "sqlserver"
            ? `  CONSTRAINT ${checkName} CHECK (${constraint.expression})`
            : `  CHECK (${constraint.expression})`;
            
          columnDefinitions.push(checkConstraint);
        });
      }
    });
    
    // Add UNIQUE constraints for multiple columns if needed
    // (For now we just handle single column unique constraints at the column level)
    
    sql += columnDefinitions.join(",\n");
    sql += "\n)";
    
    // Add table options based on dialect
    if (dialect === "mysql") {
      sql += " ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci";
    }
    
    sql += ";\n\n";
    
    // Add column comments for PostgreSQL after table creation
    if (dialect === "postgresql") {
      tableData.columns.forEach(column => {
        if (column.comment) {
          sql += `COMMENT ON COLUMN ${tableName}.${formatColumnName(column.name, dialect)} IS '${column.comment.replace(/'/g, "''")}';\n`;
        }
      });
      
      // Add table comment for PostgreSQL
      if (tableData.comment) {
        sql += `COMMENT ON TABLE ${tableName} IS '${tableData.comment.replace(/'/g, "''")}';\n`;
      }
      
      if (tableData.columns.some(c => c.comment)) {
        sql += "\n";
      }
    }
  });
  
  // Add indexes for foreign keys
  if (dialect === "mysql" || dialect === "postgresql") {
    nodes.forEach(node => {
      const tableData = node.data;
      const foreignKeys = tableData.columns.filter(col => col.isForeignKey);
      
      if (foreignKeys.length > 0) {
        foreignKeys.forEach(column => {
          const indexName = `IDX_${tableData.tableName}_${column.name}`;
          const tableName = tableData.schema && tableData.schema !== "public" && dialect === "postgresql" 
            ? `${formatSchemaName(tableData.schema, dialect)}.${formatTableName(tableData.tableName, dialect)}` 
            : formatTableName(tableData.tableName, dialect);
            
          sql += `CREATE INDEX ${indexName} ON ${tableName} (${formatColumnName(column.name, dialect)});\n`;
        });
        
        sql += "\n";
      }
    });
  }
  
  return sql;
}

function formatTableName(name: string, dialect: string = "mysql"): string {
  switch (dialect) {
    case "mysql":
      return `\`${name}\``;
    case "postgresql":
      return `"${name}"`;
    case "sqlserver":
      return `[${name}]`;
    default:
      return `\`${name}\``;
  }
}

function formatSchemaName(name: string, dialect: string = "mysql"): string {
  switch (dialect) {
    case "postgresql":
      return `"${name}"`;
    case "sqlserver":
      return `[${name}]`;
    default:
      return name;
  }
}

function formatColumnName(name: string, dialect: string = "mysql"): string {
  switch (dialect) {
    case "mysql":
      return `\`${name}\``;
    case "postgresql":
      return `"${name}"`;
    case "sqlserver":
      return `[${name}]`;
    default:
      return `\`${name}\``;
  }
}

function formatDefaultValue(value: string, type: string, dialect: string): string {
  // Handle string literals
  if ((type === "VARCHAR" || type === "TEXT" || type === "CHAR" || type === "JSON" || type === "UUID") && 
      (!value.startsWith("'") || !value.endsWith("'"))) {
    return `'${value.replace(/'/g, "''")}'`;
  }
  
  // Handle functions like NOW(), CURRENT_TIMESTAMP etc.
  if (value.toUpperCase().includes("NOW()") || value.toUpperCase().includes("CURRENT_TIMESTAMP")) {
    if (dialect === "postgresql") {
      return "CURRENT_TIMESTAMP";
    } else if (dialect === "sqlserver") {
      return "GETDATE()";
    } else {
      return "CURRENT_TIMESTAMP";
    }
  }
  
  // Handle NULL
  if (value.toUpperCase() === "NULL") {
    return "NULL";
  }
  
  // Handle boolean values
  if (type === "BOOLEAN") {
    if (value.toLowerCase() === "true") {
      return dialect === "postgresql" ? "TRUE" : "1";
    } else if (value.toLowerCase() === "false") {
      return dialect === "postgresql" ? "FALSE" : "0";
    }
  }
  
  return value;
}

function formatColumnType(column: Column, dialect: string = "mysql"): string {
  switch (column.type) {
    case "VARCHAR":
      return `VARCHAR(${column.length || 255})`;
    case "INT":
      return dialect === "postgresql" ? "INTEGER" : "INT";
    case "TEXT":
      return "TEXT";
    case "BOOLEAN":
      if (dialect === "mysql") return "TINYINT(1)";
      if (dialect === "sqlserver") return "BIT";
      return "BOOLEAN";
    case "DATE":
      return "DATE";
    case "TIMESTAMP":
      return dialect === "sqlserver" ? "DATETIME" : "TIMESTAMP";
    case "FLOAT":
      return "FLOAT";
    case "DOUBLE":
      return dialect === "postgresql" ? "DOUBLE PRECISION" : "DOUBLE";
    case "DECIMAL":
      return "DECIMAL(10,2)";
    case "JSON":
      if (dialect === "mysql" || dialect === "postgresql") return "JSON";
      if (dialect === "sqlserver") return "NVARCHAR(MAX)";
      return "JSON";
    case "UUID":
      if (dialect === "postgresql") return "UUID";
      if (dialect === "mysql") return "CHAR(36)";
      if (dialect === "sqlserver") return "UNIQUEIDENTIFIER";
      return "VARCHAR(36)";
    case "ENUM":
      if (dialect === "mysql" && column.enumValues) {
        return `ENUM(${column.enumValues.map(v => `'${v.replace(/'/g, "''")}'`).join(", ")})`;
      } else if (dialect === "postgresql" && column.enumValues) {
        // PostgreSQL would normally use a custom type, but for simplicity we'll use VARCHAR with a check constraint
        return "VARCHAR(255)";
      } else {
        return "VARCHAR(255)";
      }
    case "ARRAY":
      if (dialect === "postgresql") return "TEXT[]";
      return "TEXT"; // Most non-PostgreSQL DBs don't support arrays natively
    case "CUSTOM":
      return "VARCHAR(255)"; // Fallback for custom types
    default:
      return "VARCHAR(255)";
  }
}

export function formatSQLForDisplay(sql: string): string {
  // Highlight SQL keywords
  let formattedSql = sql
    .replace(/\b(CREATE|TABLE|PRIMARY|KEY|FOREIGN|REFERENCES|INT|VARCHAR|TEXT|BOOLEAN|DATE|TIMESTAMP|FLOAT|DOUBLE|DECIMAL|NOT|NULL|UNIQUE|CHECK|DEFAULT|INDEX|ON|COMMENT|IS|ENGINE|CHARSET|COLLATE)\b/g, match => 
      `<span class="keyword">${match}</span>`
    )
    // Highlight table names
    .replace(/(`|\[|")([^`\["]+)(`|\]|")/g, (match, open, tableName, close) => 
      `<span class="table-name">${open}${tableName}${close}</span>`
    )
    // Highlight data types
    .replace(/<span class="keyword">(INT|INTEGER|VARCHAR|TEXT|BOOLEAN|TINYINT|BIT|DATE|TIMESTAMP|DATETIME|FLOAT|DOUBLE|DECIMAL|JSON|UUID|CHAR|ENUM|ARRAY)<\/span>(\(\d+(?:,\d+)?\))?/g, (match, dataType, size) => 
      `<span class="data-type">${dataType}${size || ''}</span>`
    )
    // Highlight constraints
    .replace(/<span class="keyword">(PRIMARY|KEY|FOREIGN|REFERENCES|NOT|NULL|UNIQUE|CHECK|DEFAULT|INDEX|CONSTRAINT)<\/span>/g, (match, constraint) => 
      `<span class="constraint">${constraint}</span>`
    )
    // Highlight comments
    .replace(/(--.*$)/gm, match => 
      `<span class="comment">${match}</span>`
    );
  
  return formattedSql;
}

// Function to suggest relationships between tables based on column names and data types
export function suggestRelationships(nodes: TableData[]): RelationshipSuggestion[] {
  const suggestions: RelationshipSuggestion[] = [];
  
  for (const sourceTable of nodes) {
    for (const targetTable of nodes) {
      if (sourceTable.id === targetTable.id) continue;
      
      // Look for potential foreign key relationships
      for (const targetColumn of targetTable.columns) {
        // Check if column name matches pattern "tablename_id" or "tablenameid"
        const possibleSourceTableName = sourceTable.tableName.toLowerCase();
        const columnNameLower = targetColumn.name.toLowerCase();
        
        if (columnNameLower === `${possibleSourceTableName}_id` || 
            columnNameLower === `${possibleSourceTableName}id`) {
          
          // Find the primary key in the source table
          const sourcePK = sourceTable.columns.find(col => col.isPrimaryKey);
          
          if (sourcePK && targetColumn.type === sourcePK.type) {
            suggestions.push({
              sourceTable: sourceTable.tableName,
              targetTable: targetTable.tableName,
              relationshipType: 'one-to-many',
              confidence: 0.8,
              reason: `Column name "${targetColumn.name}" in "${targetTable.tableName}" suggests a relationship with "${sourceTable.tableName}"`
            });
          }
        }
      }
      
      // Look for many-to-many relationships (junction tables)
      if (targetTable.columns.length >= 2 && 
          targetTable.columns.filter(col => col.isForeignKey).length >= 2) {
        
        // Check if this is potentially a junction table between sourceTable and another table
        const sourceTableFK = targetTable.columns.find(col => 
          col.isForeignKey && col.referencesTable === sourceTable.tableName);
          
        if (sourceTableFK) {
          // Find foreign keys to other tables
          const otherFKs = targetTable.columns.filter(col => 
            col.isForeignKey && col.referencesTable !== sourceTable.tableName);
            
          for (const otherFK of otherFKs) {
            suggestions.push({
              sourceTable: sourceTable.tableName,
              targetTable: otherFK.referencesTable!,
              relationshipType: 'many-to-many',
              confidence: 0.7,
              reason: `Junction table "${targetTable.tableName}" suggests a many-to-many relationship between "${sourceTable.tableName}" and "${otherFK.referencesTable}"`
            });
          }
        }
      }
      
      // Check for table inheritance patterns (postgresql specific)
      if (targetTable.columns.length > 0 && sourceTable.columns.length > 0) {
        // Simple heuristic: if target table has ALL columns from source table plus additional ones
        const sourceColNames = new Set(sourceTable.columns.map(c => c.name.toLowerCase()));
        const targetColNames = new Set(targetTable.columns.map(c => c.name.toLowerCase()));
        
        // Check if target contains all source columns
        let containsAllSourceCols = true;
        for (const colName of sourceColNames) {
          if (!targetColNames.has(colName)) {
            containsAllSourceCols = false;
            break;
          }
        }
        
        // And has additional columns
        if (containsAllSourceCols && targetColNames.size > sourceColNames.size) {
          suggestions.push({
            sourceTable: sourceTable.tableName,
            targetTable: targetTable.tableName,
            relationshipType: 'inheritance',
            confidence: 0.6,
            reason: `"${targetTable.tableName}" contains all columns from "${sourceTable.tableName}" plus additional ones, suggesting inheritance`
          });
        }
      }
    }
  }
  
  return suggestions;
}

// Parse SQL to generate diagram
export function parseSQL(sql: string): DiagramState {
  const lines = sql.split('\n');
  const nodes: TableData[] = [];
  const edges: any[] = [];
  
  let currentTable: TableData | null = null;
  let tableName = '';
  let currentSchema = 'public';
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Skip comments
    if (line.startsWith('--') || line.startsWith('/*') || line === '' || line === ';') {
      continue;
    }
    
    // Check for CREATE TABLE statement
    const createTableMatch = line.match(/CREATE\s+TABLE\s+(?:([`"\[]?)([^`"\[\s.]+)([`"\]]?)\.)?([`"\[]?)([^`"\[\s().]+)([`"\]]?)\s*\(/i);
    if (createTableMatch) {
      const schemaName = createTableMatch[2];
      tableName = createTableMatch[5].replace(/[`"\[\]]/g, '');
      const tableId = `table-${Date.now()}-${nodes.length}`;
      
      currentTable = {
        id: tableId,
        tableName,
        schema: schemaName || 'public',
        columns: []
      };
      
      continue;
    }
    
    // End of table definition
    if ((line === ');' || line.startsWith(')') || line === '}' || line === '})')  && currentTable) {
      nodes.push(currentTable);
      currentTable = null;
      continue;
    }
    
    // Skip if not in a table definition
    if (!currentTable) continue;
    
    // Check for column definition
    const columnMatch = line.match(/^\s*[`"\[]?([^`"\[\s,]+)[`"\]]?\s+([A-Za-z0-9()[\]]+)(.+)?[,]?$/);
    if (columnMatch && !line.startsWith('PRIMARY KEY') && !line.startsWith('FOREIGN KEY') && !line.startsWith('CHECK') && !line.startsWith('CONSTRAINT')) {
      const columnName = columnMatch[1];
      const columnType = columnMatch[2].toUpperCase();
      const columnOptions = columnMatch[3] || '';
      
      const isPrimaryKey = /PRIMARY\s+KEY/i.test(columnOptions);
      const isNullable = !/NOT\s+NULL/i.test(columnOptions);
      const isUnique = /UNIQUE/i.test(columnOptions);
      
      let parsedType = columnType.split('(')[0].trim() as any;
      if (parsedType === 'INTEGER') parsedType = 'INT';
      if (parsedType === 'TINYINT') parsedType = 'BOOLEAN';
      if (parsedType === 'BIT') parsedType = 'BOOLEAN';
      if (parsedType === 'DATETIME') parsedType = 'TIMESTAMP';
      
      const lengthMatch = columnType.match(/\((\d+)\)/);
      const length = lengthMatch ? parseInt(lengthMatch[1]) : undefined;
      
      const constraints: Constraint[] = [];
      
      // Check for DEFAULT constraint
      const defaultMatch = columnOptions.match(/DEFAULT\s+([^,\s]+)/i);
      if (defaultMatch) {
        constraints.push({
          type: 'DEFAULT',
          defaultValue: defaultMatch[1]
        });
      }
      
      // Check for CHECK constraint
      const checkMatch = columnOptions.match(/CHECK\s+\((.+?)\)/i);
      if (checkMatch) {
        constraints.push({
          type: 'CHECK',
          expression: checkMatch[1]
        });
      }
      
      // Check for comment
      const commentMatch = columnOptions.match(/COMMENT\s+['"](.*?)['"]?/i);
      const comment = commentMatch ? commentMatch[1] : undefined;
      
      const column: Column = {
        id: `${currentTable.id}-col-${currentTable.columns.length}`,
        name: columnName,
        type: parsedType,
        length,
        isPrimaryKey,
        isForeignKey: false,
        isNullable,
        isUnique,
        constraints: constraints.length > 0 ? constraints : undefined,
        comment
      };
      
      currentTable.columns.push(column);
    }
    
    // Check for FOREIGN KEY constraints
    const fkMatch = line.match(/(?:CONSTRAINT\s+[`"\[]?([^`"\[\s)]+)[`"\]]?\s+)?FOREIGN\s+KEY\s+\(\s*[`"\[]?([^`"\[\s)]+)[`"\]]?\s*\)\s+REFERENCES\s+(?:[`"\[]?([^`"\[\s.]+)[`"\]]?\.)?[`"\[]?([^`"\[\s(]+)[`"\]]?\s*\(\s*[`"\[]?([^`"\[\s)]+)[`"\]]?\s*\)/i);
    if (fkMatch && currentTable) {
      const constraintName = fkMatch[1]; // May be undefined
      const fkColumnName = fkMatch[2];
      const refSchemaName = fkMatch[3] || 'public';
      const refTableName = fkMatch[4];
      const refColumnName = fkMatch[5];
      
      // Find the column
      const column = currentTable.columns.find(col => col.name === fkColumnName);
      if (column) {
        column.isForeignKey = true;
        column.referencesTable = refTableName;
        column.referencesColumn = refColumnName;
      }
    }
    
    // Check for separate PRIMARY KEY constraint
    const pkMatch = line.match(/(?:CONSTRAINT\s+[`"\[]?([^`"\[\s)]+)[`"\]]?\s+)?PRIMARY\s+KEY\s+\(\s*([^)]+)\s*\)/i);
    if (pkMatch && currentTable) {
      const pkColumns = pkMatch[2].split(',').map(col => col.trim().replace(/[`"\[\]]/g, ''));
      
      pkColumns.forEach(pkColName => {
        const column = currentTable!.columns.find(col => col.name === pkColName);
        if (column) {
          column.isPrimaryKey = true;
          column.isNullable = false;
        }
      });
    }
    
    // Check for separate UNIQUE constraint
    const uniqueMatch = line.match(/(?:CONSTRAINT\s+[`"\[]?([^`"\[\s)]+)[`"\]]?\s+)?UNIQUE\s+\(\s*([^)]+)\s*\)/i);
    if (uniqueMatch && currentTable) {
      const uniqueColumns = uniqueMatch[2].split(',').map(col => col.trim().replace(/[`"\[\]]/g, ''));
      
      uniqueColumns.forEach(uniqueColName => {
        const column = currentTable!.columns.find(col => col.name === uniqueColName);
        if (column) {
          column.isUnique = true;
        }
      });
    }
    
    // Check for separate CHECK constraint
    const checkMatch = line.match(/(?:CONSTRAINT\s+[`"\[]?([^`"\[\s)]+)[`"\]]?\s+)?CHECK\s+\(\s*([^)]+)\s*\)/i);
    if (checkMatch && currentTable) {
      const constraintName = checkMatch[1]; // May be undefined
      const checkExpression = checkMatch[2];
      
      // Since we can't easily determine which column this check applies to,
      // we'll add it to the first column as a simplification
      if (currentTable.columns.length > 0) {
        const firstColumn = currentTable.columns[0];
        if (!firstColumn.constraints) {
          firstColumn.constraints = [];
        }
        firstColumn.constraints.push({
          type: 'CHECK',
          expression: checkExpression
        });
      }
    }
  }
  
  // Generate edges based on foreign keys
  for (const table of nodes) {
    for (const column of table.columns) {
      if (column.isForeignKey && column.referencesTable && column.referencesColumn) {
        const targetTable = nodes.find(t => t.tableName === column.referencesTable);
        if (targetTable) {
          edges.push({
            id: `edge-${Date.now()}-${edges.length}`,
            source: targetTable.id,
            target: table.id,
            animated: true,
            style: { stroke: '#525252' },
            markerEnd: {
              type: 'arrowclosed',
              color: '#525252',
            },
            data: {
              relationshipType: 'one-to-many',
              sourceColumn: column.referencesColumn,
              targetColumn: column.name
            }
          });
        }
      }
    }
  }
  
  return {
    nodes: nodes.map((tableData, index) => ({
      id: tableData.id,
      type: 'tableNode',
      position: { x: 100 + (index * 300), y: 100 + (index * 50) },
      data: tableData
    })),
    edges
  };
}
